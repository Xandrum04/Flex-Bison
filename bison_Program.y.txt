%{ 
/* DEFINITIONS*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
%}

/*DECLARATIONS*/
%token START END IF ELSE ELSE_IF WHILE DO FOR SWITCH CASE DEFAULT BREAK RETURN CLASS PUBLIC PRIVATE INT CHAR DOUBLE BOOLEAN STRING TRUE FALSE NEW OUT_PRINT SEMICOLON LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET ASSIGN COMMA PLUS MINUS MULT DIV LESS_THAN GREATER_THAN EQUAL NOT_EQUAL LESS_THAN_EQUAL GREATER_THAN_EQUAL AND OR MODULO HASH AT CARET QUESTION_MARK SINGLE_QUOTE DOUBLE_QUOTE UNDERSCORE DOT EXCLAMATION_POINT PIPE STRING_LITERAL ONE_LINE_COMMENT MULTIPLE_LINE_COMMENTS IDENTIFIER NUMBER

%
%left '+' '-'
%left '*' '/'
%nonassoc UMINUS


%type <string> STRING
%type <num> NUMBER
%type <string> IDENTIFIER
%type <num> DIGIT

%union {
    int num;
    char string[];
}

%%
  /* RULES / BNF */


PROGRAM: START STATEMENTS END { printf("Program parsed successfully.\n"); };

STATEMENTS : STATEMENT                 { printf("Statement\n"); }
           | STATEMENT  STATEMENTS     { printf("Statement\n"); }
           ;
STATEMENT : STATEMENT_IF               { printf("Statement\n"); }
          | STATEMENT_WHILE            { printf("Statement\n"); }
          | STATEMENT_ASSIGN           { printf("Statement\n"); }
          | STATEMENT_SWITCH           { printf("Statement\n"); }
          | STATEMENT_RETURN           { printf("Statement\n"); }
          | STATEMENT_CLASS            { printf("Statement\n"); }
          | VARIABLE_DECLARATION       { printf("Statement\n"); }
          | METHOD_DECLARATION         { printf("Statement\n"); }
          | STATEMENT_DO_WHILE         { printf("Statement\n"); }
          | STATEMENT_FOR              { printf("Statement\n"); }
          | STATEMENT_PRINT            { printf("Statement\n"); }
          | CREATE_CLASS_OBJECT        { printf("Statement\n"); }
          | STATEMENT_BREAK            { printf("Statement\n"); }
          | COMMENTS                   { printf("Comment\n"); }
          ;

STATEMENT_IF: IF LPAREN CONDITION RPAREN LBRACE STATEMENTS RBRACE { printf("IF Statement\n"); }
            | IF LPAREN CONDITION RPAREN STATEMENTS STATEMENT_ELSE_IF ELSE LBRACE STATEMENTS RBRACE { printf("IF ELSE Statement\n"); }
            ;

STATEMENT_ELSE_IF: ELSE_IF LPAREN CONDITION RPAREN LBRACE STATEMENTS RBRACE
                 | LPAREN CONDITION RPAREN LBRACE STATEMENTS RBRACE STATEMENT_ELSE_IF
                 ;

STATEMENT_WHILE: WHILE LPAREN CONDITION RPAREN LBRACE STATEMENTS RBRACE { printf("WHILE Statement\n"); }
               ;

STATEMENT_BREAK: BREAK SEMICOLON { printf("BREAK Statement\n"); }
               ;

STATEMENT_ASSIGN: VARIABLE EQUALS EXPRESSION SEMICOLON { printf("Assignment Statement\n"); }
                ;

STATEMENT_SWITCH: SWITCH LPAREN EXPRESSION RPAREN SWITCH_BODY { printf("SWITCH Statement\n"); }
                ;

SWITCH_BODY: CASE EXPRESSION COLON STATEMENT { printf("CASE Statement\n"); }
           | CASE EXPRESSION COLON STATEMENT DEFAULT COLON STATEMENT { printf("DEFAULT Statement\n"); }
           | CASE EXPRESSION COLON STATEMENT SWITCH_BODY { printf("CASE Statement\n"); }
           ;

STATEMENT_RETURN: RETURN EXPRESSION SEMICOLON { printf("RETURN Statement\n"); }
                ;

STATEMENT_CLASS: ACCESS_MODIFIER CLASS CLASS_IDENTIFIER LBRACE VARIABLE_DECLARATION METHOD_DECLARATION RBRACE{ printf("CLASS Statement\n"); }
               ;

CLASS_IDENTIFIER: UPPERCASE
                | UPPERCASE IDENTIFIER
                ;

CREATE_CLASS_OBJECT: CLASS_IDENTIFIER IDENTIFIER EQUALS STATEMENT_NEW LBRACE RBRACE SEMICOLON { printf("Create Class Object Statement\n"); }
                   ;

STATEMENT_DO_WHILE: DO LBRACE STATEMENTS RBRACE WHILE LPAREN CONDITION RPAREN { printf("DO WHILE Statement\n"); }
                  ;

ACCESS_TO_CLASS_MEMBERS: IDENTIFIER DOT IDENTIFIER SEMICOLON { printf("Access to Class Members Statement\n"); }
                       ;

STATEMENT_FOR: FOR LPAREN STATEMENT_ASSIGN SEMICOLON CONDITION SEMICOLON STATEMENT_ASSIGN RPAREN LBRACE RBRACE { printf("FOR Statement\n"); }
             ;


COMMENTS : ONE_LINE_COMMENT { printf("One Line Comment\n"); }
         | MULTIPLE_LINE_COMMENTS { printf("Multiple Line Comment\n"); }
         ;

STATEMENT_PRINT: OUT.PRINT LPAREN STRING_LITERAL RPAREN SEMICOLON { printf("Print Statement\n"); }
               | OUT.PRINT LPAREN STRING_LITERAL COMMA EXPRESSION RPAREN SEMICOLON { printf("Print Statement\n"); }
               ;

VARIABLE_DECLARATION: ACCESS_MODIFIER VARIABLE_TYPE IDENTIFIER SEMICOLON { printf("Variable Declaration\n"); }
                    | VARIABLE_TYPE IDENTIFIER SEMICOLON { printf("Variable Declaration\n"); }
                    ;

METHOD_DECLARATION: ACCESS_MODIFIER RETURN_TYPE IDENTIFIER LPAREN RPAREN LBRACE STATEMENTS RBRACE  { printf("Method Declaration\n"); }
                  | ACCESS_MODIFIER RETURN_TYPE IDENTIFIER LPAREN PARAMETER_LIST RPAREN LBRACE STATEMENTS RBRACE  { printf("Method Declaration\n"); }
                  | ACCESS_MODIFIER RETURN_TYPE IDENTIFIER LPAREN RPAREN LBRACE VARIABLE_DECLARATION STATEMENTS RBRACE  { printf("Method Declaration\n"); }
                  | ACCESS_MODIFIER RETURN_TYPE IDENTIFIER LPAREN PARAMETER_LIST RPAREN LBRACE VARIABLE_DECLARATION STATEMENTS RBRACE  { printf("Method Declaration\n"); }
                  ;

RETURN_TYPE: VARIABLE_TYPE { printf("Return Type\n"); }
           | VOID { printf("Void\n"); }
           ;

ACCESS_MODIFIER: PUBLIC { printf("Public\n"); }
               | PRIVATE { printf("Private\n"); }
               ;

VARIABLE_TYPE: INT { printf("Int\n"); }
              | CHAR { printf("Char\n"); }
              | DOUBLE { printf("Double\n"); }
              | BOOLEAN { printf("Boolean\n"); }
              | STRING { printf("String\n"); }
              ;


PARAMETER_LIST : VARIABLE_TYPE IDENTIFIER COMMA PARAMETER_LIST { printf("Parameter List\n"); }
               | VARIABLE_TYPE IDENTIFIER { printf("Parameter List\n"); }
               ;



CONDITION : EXPRESSION COMPARISON EXPRESSION { printf("Condition\n"); }
          | EXPRESSION COMPARISON EXPRESSION AND CONDITION { printf("Condition\n"); }
          | EXPRESSION COMPARISON EXPRESSION OR CONDITION { printf("Condition\n"); }
          ;

COMPARISON : LESS_THAN { printf("Comparison\n"); }
           | GREATER_THAN { printf("Comparison\n"); }
           | LESS_THAN_EQUAL { printf("Comparison\n"); }
           | GREATER_THAN_EQUAL { printf("Comparison\n"); }
           | IS_EQUAL { printf("Comparison\n"); }
           | NOT_EQUAL { printf("Comparison\n"); }
           ;

EXPRESSION : VALUE { printf("Expression\n"); }
           | OPERATION { printf("Expression\n"); }
           | STATEMENT_NEW { printf("Expression\n"); }
           | BOOLEAN { printf("Expression\n"); }
           ;

BOOLEAN : TRUE { printf("True\n"); }
        | FALSE { printf("False\n"); }
        ;

STATEMENT_NEW : NEW VARIABLE_TYPE { printf("New Statement\n"); }
              | NEW CLASS_IDENTIFIER { printf("New Statement\n"); }
              ;

VALUE : NUMBER { printf("Value\n"); }
      | IDENTIFIER { printf("Value\n"); }
      ;
 
OPERATION : ADDITION { printf("Operation\n"); }
          | MULTIPLICATION { printf("Operation\n"); }
          | SUBTRACTION { printf("Operation\n"); }
          | DIVISION { printf("Operation\n"); }
          ;

OPERATION_CONTINUE : 
                   |PLUS LPAREN OPERATION RPAREN { printf("Operation Continue PLUS\n"); }
                   | MINUS LPAREN OPERATION RPAREN { printf("Operation Continue MINUS\n"); }
                   | MULT LPAREN OPERATION RPAREN { printf("Operation Continue MULT\n"); }
                   | DIV LPAREN OPERATION RPAREN { printf("Operation Continue DIV\n"); }
                   ;

ADDITION: VALUE PLUS VALUE OPERATION_CONTINUE { printf("Addition\n"); }
        ;
       
MULTIPLICATION : VALUE MULT VALUE OPERATION_CONTINUE { printf("Multiplication\n"); }


SUBTRACTION : VALUE MINUS VALUE OPERATION_CONTINUE { printf("Subtraction\n"); }
            ;


DIVISION : VALUE DIV VALUE OPERATION_CONTINUE { printf("Division\n"); }
         ;

IDENTIFIER : LETTER { printf("Identifier\n"); }
           | IDENTIFIER LETTER { printf("Identifier\n"); }
           | IDENTIFIER NUMBER { printf("Identifier\n"); }
           | IDENTIFIER UNDERSCORE { printf("Identifier\n"); }
           ;

NUMBER : DIGIT { printf(" Number\n");}
       | NUMBER DIGIT { printf("Numbers\n"); }

LETTER: UPPERCASE { printf("Uppercase letter\n"); }
      | LOWERCASE { printf("Lowercase letter\n"); }
      ;

STRING_LITERAL: DOUBLE_QUOTE CHARACTERS DOUBLE_QUOTE; { printf("String literal\n"); }


CHARACTERS: CHARACTER { printf("Character\n");}
          | CHARACTER CHARACTERS  { printf(" Characters\n");}
          ;

CHARACTER: DIGIT { printf("Character->Digit\n"); }
         | LETTER { printf("Character->letter\n"); }
         | SPECIAL_CHARACTERS { printf("Special Characters\n"); }
         ;





%%
 /* CODE */

void yyerror(char *s)
{
  printf("Syntax Error in line %s\n",s);
  return 0;
}

int main(int argc, char* argv[]){

if (argc < 2) {
        fprintf(stderr, "Usage: %s <input_file>\n", argv[0]);
        return 1;
    }

    yyin = fopen(argv[1], "r");
    if (!yyin) {
        fprintf(stderr, "Error opening file %s\n", argv[1]);
        return 1;
    }

    yyparse();

    fclose(yyin);
    return 0;

}
 



